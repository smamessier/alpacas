package com.uber.atcp.dsl.stateImpl

import org.scalacheck._
import org.scalacheck.Prop.forAll
import Gen._

import com.uber.atcp.dsl._
import com.uber.atcp.dsl.Modelling.{_, given _}
import com.uber.atcp.dsl.causalModel._
import com.uber.atcp.dsl.step._
import com.uber.atcp.dsl.Analysis._
import com.uber.atcp.dsl.ast._
import com.uber.atcp.dsl.exprEval._

import scala.language.implicitConversions

/** We check that the implementation of states corresponds to the requirements given in module Step. 
  * States are updated with values generated by property-based testing. */
object StateImplSpec extends Properties("State Implementation") {

  val testComp = TestComponent()

  val causalModel : CausalModel = 
    compCheck(testComp) match
      case Right(cm) => cm
      case Left(err) => null
  
  val state = mutableInitialState(causalModel)  
  
  property("mutableIntState") = forAll{(a : Int) =>
    StepTests.testUpdateState(mutableInitialState(causalModel), testComp.stateInt, a)
  }

  property("mutableBoolState") = forAll{(a : Boolean) =>
    StepTests.testUpdateState(mutableInitialState(causalModel), testComp.stateBool, a)
  }

  property("mutableIntFlow") = forAll{(a : Int) =>
    StepTests.testUpdateFlow(mutableInitialState(causalModel), testComp.outFlowInt, a)
  }

  property("mutableBoolFlow") = forAll{(a : Boolean) =>
    StepTests.testUpdateFlow(mutableInitialState(causalModel), testComp.outFlowBool, a)
  }

  property("mutableReadFlow") = 
    StepTests.testReadUndefFlow(mutableInitialState(causalModel), testComp.outFlowBool)

  property("mutableReadStateDuring") = forAll{(a : Int, b : Int) =>
    StepTests.testReadStateDuring(mutableInitialState(causalModel), testComp.stateInt, a, b)
  }
  property("mutableResetState") = forAll{(a : Int) =>
    StepTests.testResetState(mutableInitialState(causalModel), testComp.stateInt, a, causalModel)
  }
  property("mutableResetFlow") = forAll{(a : Int) =>
    StepTests.testResetFlow(mutableInitialState(causalModel), testComp.outFlowInt, a, causalModel)
  }


  property("immutableIntState") = forAll{(a : Int) =>
    StepTests.testUpdateState(immutableInitialState(causalModel), testComp.stateInt, a)
  }

  property("immutableBoolState") = forAll{(a : Boolean) =>
    StepTests.testUpdateState(immutableInitialState(causalModel), testComp.stateBool, a)
  }

  property("immutableIntFlow") = forAll{(a : Int) =>
    StepTests.testUpdateFlow(immutableInitialState(causalModel), testComp.outFlowInt, a)
  }

  property("immutableBoolFlow") = forAll{(a : Boolean) =>
    StepTests.testUpdateFlow(immutableInitialState(causalModel), testComp.outFlowBool, a)
  }


  property("immutableReadFlow") = 
    StepTests.testReadUndefFlow(immutableInitialState(causalModel), testComp.outFlowBool)
  
  property("immutableReadStateDuring") = forAll{(a : Int, b : Int) =>
    StepTests.testReadStateDuring(immutableInitialState(causalModel), testComp.stateInt, a, b)
  }
  property("immutableResetState") = forAll{(a : Int) =>
    StepTests.testResetState(immutableInitialState(causalModel), testComp.stateInt, a, causalModel)
  }
  property("immutableResetFlow") = forAll{(a : Int) =>
    StepTests.testResetFlow(immutableInitialState(causalModel), testComp.outFlowInt, a, causalModel)
  }

}